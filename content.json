{"meta":{"title":"MY BLOG","subtitle":null,"description":"每天进步一点点，人生精彩无极限。","author":"vijing","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Camera测试之Color & Lens shading Test","slug":"2018-10-13_Camera测试之Color & Lens shading Test","date":"2018-10-13T03:19:26.211Z","updated":"2018-10-13T03:41:28.699Z","comments":true,"path":"2018/10/13/2018-10-13_Camera测试之Color & Lens shading Test/","link":"","permalink":"http://yoursite.com/2018/10/13/2018-10-13_Camera测试之Color & Lens shading Test/","excerpt":"","text":"标签： 原创 工作总结 测试目的：测试摄像头成像的均匀性测试主要设备：均匀光源（DNP灯箱），色温照度计测试环境：将灯箱光源调至600±100lux测试注意事项：保证均匀的光源测试原理：造成摄像头成像不均匀的原因有两个：1.摄像头成像原理是透镜成像，光线透过透镜中心和透过透镜边缘会有不同的折射，所以会导致lens shading。不同波长的光折射率不一样，所以会导致color shading。2.镜头CRA(chief ray angle)和Sensor CRA不匹配也会导致color&amp;lens shading。下面分别介绍Lens shading和colorshading的测试方法和原理。Color&amp;Lensshading测试时会先让camera在拍摄白板或者拍摄灰卡得到图片。 一.Lens shading测试原理如上图所示，测试Lens shading时，取camera拍摄白板或者拍摄灰卡得到的图片中心和四周区域3232或者100100（一般会选择图片长宽的1/20），1.分别计算每个区域的平均灰度值2.然后将四个角四个区域的平均灰度值除以中心区域的平均灰度值3.将第二步计算结果拿去判断Pass or fail 二．Color shading测试原理：Color shading测试原理与lens shading测试很相似，也是先取camera拍摄白板或者拍摄灰卡得到的图片中心和四周区域3232或者100100（一般会选择图片长宽的1/20）1.分别计算每个区域的平均R,G,B的值2.分别计算每个区域的 平均R值/平均G值 平均B值/平均G值将四角四个区域的 平均R值/平均G值 平均B值/平均G值 除以中心区域的 平均R值/平均G值 平均B值/平均G值 判断标准：一般来说，Lens shading测试结果Pass的标准为0.85~1.15。Color shading测试结果为Pass的标准为0.95~1.05。","categories":[],"tags":[]},{"title":"Color&Lens shading测试图卡位置检测","slug":"2018-10-13_Color&Lens shading测试图卡位置检测","date":"2018-10-13T03:14:44.318Z","updated":"2018-10-13T03:31:51.189Z","comments":true,"path":"2018/10/13/2018-10-13_Color&Lens shading测试图卡位置检测/","link":"","permalink":"http://yoursite.com/2018/10/13/2018-10-13_Color&Lens shading测试图卡位置检测/","excerpt":"","text":"标签（空格分隔）： 原创 工作总结 进行测试之前，最重要的一步就是确保测试环境是正常的。对于camera测试来说，测试之前很重要的一步就是要确保camera和图卡的位置是正确的。在实际产测中，如果每个DUT测试之前都需要人去确认camera和图卡的位置是否符合要求，则会消耗大量的人力物力。所以需要写一个程序在开始测试之前判断camera和图卡的位置是否正确，如果正确则开始测试。如果错误则停止测试。因为在同一个工站可能会测试camera的两个测试项，例如同时测试camera的MTF和Color&amp;Lensshading。这样的话测试过程中则需要转换图卡。转换图卡的过程中可能会出现错误意外。首先我们先分析一下图卡切换到位和切换不到位情况拍摄的图片有什么不同。图卡位置正确图卡位置正确灰度直方图图卡位置错误图卡位置错误灰度直方图 图卡位置正确和图卡位置错误灰度值灰度直方图分布有差异，可用一阈值进行二值化处理流程如下： 处理流程图 根据上图的处理流程之后，就可以判断camera和图卡的位置是否正确。","categories":[],"tags":[]},{"title":"英语简单句类型","slug":"2018-09-28_英语简单句类型","date":"2018-09-27T15:59:43.442Z","updated":"2018-09-27T16:12:17.810Z","comments":true,"path":"2018/09/27/2018-09-28_英语简单句类型/","link":"","permalink":"http://yoursite.com/2018/09/27/2018-09-28_英语简单句类型/","excerpt":"","text":"标签（空格分隔）： 英语 类型1 主语 + 系动词 + 表语 系动词 例子 系动词 be 与感官有关 look,smell, sound, feel, taste 与保持有关 keep, remain, stay, stand, lie… 与变化有关 get, become, turn, go, grow, fall, come.. 类型2 主语 + 谓语由“主语 + 不及物动（SVi）”构成主谓系统。不及物动词后面要加上介词才能接跟宾语，所以叫不及物动词。理论上说，“主语+不及物动词”就可以构成正确的句子，已过加上次要的附属结构，有下面几种情况： 句型变化 例子 SVi + 介词 + 宾语 He arrived at the factory SVi + 副词 He arrived soon SVi + to do… He came to see his mother 特殊词 + Vi + S(名词.) Here comes the bus 类型3 主语 + 谓语 + 宾语由“主语 + 及物动词 + 宾语”（SVO）构成主谓系统。及物动词后面马上跟宾语，不需要在动宾之间加上介词，所以叫及物动词。 SVt + 名/代 + （介宾） SVt + 非谓语形式 SVt +(to+sb/sth）+从句 类型4 主语 + 谓语 + 间接宾语 + 直接宾语 句型变化 同类词 例句 SVt +直宾 + to + 间宾 afford, lend, leave, hand, offer, owe, 等等 The teacher gave a book to me/the boy SVt +直宾 + for + 间宾 Buy, call, cook, choose, do, draw, find, get, make,等等 My mother cooked a mal for me/her son SVt + 间宾 + 复合不定式直宾/从句直宾 包括前面两类动词 The teacher gave me/the boy a book SVt + 间宾 + 复合不定式直宾/从句直宾 learn, teach, show, tell, point out He showed me how to swim. （复合不定式充当直接宾语）He told me where I should go.（从句充当直接宾语）He told me that the news was true. （从句充当直接宾语） SVt +to +间宾 +从句直宾 suggest, reply,explain, point out等等 He replied to me that the news was true. （从句充当直接宾语） 类型5 主语 + 谓语 + 宾语 + 宾补 SVt + 宾语 + 形/副/介/名 SVt + 宾语+非谓语形式 SVt + it + 形/名+ to do SVt + it + 形/名/介宾 + 从句","categories":[],"tags":[]},{"title":"颜色空间","slug":"2018-09-19Color_Space","date":"2018-09-19T15:54:31.684Z","updated":"2018-09-19T15:55:52.105Z","comments":true,"path":"2018/09/19/2018-09-19Color_Space/","link":"","permalink":"http://yoursite.com/2018/09/19/2018-09-19Color_Space/","excerpt":"","text":"颜色空间我们经常看到RGB,YUV,HSL,Lab等这些名词来描述颜色，那么这些名词之间有怎样的具体又是指什么东西呢？RGB,CMYK,HSL,Lab,YUV这些属于颜色空间，颜色空间，简单来说就是颜色在不同的应用场景和应用背景的表示方式。 RGBRGB主要应用于显示器系统，彩色阴极射线管,彩色光栅图形的显示器，也就是说RGB面向硬件。RGB又分为Adobe RGB和sRGB,AdobeRGB能表示的范围要大一些。就是说如果你使用8位JPG文件，你最好使用sRGB。如果你使用16位文件，可能选择Adobe RGB更合适。 CMYKCMYK(cyan,magenta,yellow)颜色空间应用于印刷工业,印刷业通过青(C)、品(M)、黄(Y)三原色油墨的不同 网点面积率的叠印来表现丰富多彩的颜色和阶调，这便是三原色的CMY颜色空间。实际印刷中，一般采用青 (C)、品(M)、黄(Y)、黑(BK)四色印刷，在印刷的中间调至暗调增加黑版。 HSVRGB和CMY颜色模型都是面向硬件的，而HSV（Hue Saturation Value）颜色模型是面向用户的。这个模型中颜色的参数分别是：色调（H：hue），饱和度（S：saturation），亮度（V：value）。这是根据人观察色彩的生理特征而提出的颜色模型（人的视觉系统对亮度的敏感度要强于色彩值，这也是为什么计算机视觉中通常使用灰度即亮度图像来处理的原因之一） HSV模型的三维表示从RGB立方体演化而来。设想从RGB沿立方体对角线的白色顶点向黑色顶点观察，就可以看到立方体的六边形外形。六边形边界表示色彩，水平轴表示纯度，明度沿垂直轴测量。与加法减法混色的术语相比，使用色相，饱和度等概念描述色彩更自然直观。 LabLab颜色被设计来接近人类视觉。它致力于感知均匀性，它的L分量密切匹配人类亮度感知。因此可以被用来通过修改a和b分量的输出色阶来做精确的颜色平衡，或使用L分量来调整亮度对比。Lab颜色空间是由CIE(国际照明委员会)制定的一种色彩模式。自然界中任何一点色都可以在Lab空间中表达出来，它的色彩空间比RGB空间还要大。另外，这种模式是以数字化方式来描述人的视觉感应， 与设备无关，所以它弥补了RGB和CMYK模式必须依赖于设备色彩特性的不足。 YUV YUV色彩空间的重要性是它的亮度信号Y和色度信号U、V是分离的。如果只有Y信号分量而没有U、V分量， 那么这样表示的图就是黑白灰度图。彩色电视采用YUV空间正是为了用亮度信号Y解决彩色电视机与黑白电视机 的兼容问题，使黑白电视机也能接收彩色信号。 YUV是通过亮度-色差来描述颜色的颜色空间。 亮度信号经常被称作Y，色度信号是由两个互相独立的信号组成。视颜色系统和格式不同，两种色度信号经常被称作UV或PbPr或CbCr。这些都是由不同的编码格式所产生的，但是实际上，他们的概念基本相同。在DVD中，色度信号被存储成Cb和Cr（C代表颜色，b代表蓝色，r代表红色） YUV颜色空间是从RGB颜色空间推导而来。 RGB和YUV的换算公式如下： Y = 0.299 R&apos; + 0.587 G&apos; + 0.114 B&apos; U = -0.147 R&apos; 0.289 G&apos; + 0.436 B&apos; = 0.492(B&apos;- Y) V = 0.615 R&apos; 0.289 G&apos; + 0.436 B&apos; = 0.877(R&apos;- Y)","categories":[],"tags":[]},{"title":"python实现ssh远程登录","slug":"2018-08-21_Python实现ssh登录","date":"2018-08-21T14:59:26.324Z","updated":"2018-08-21T15:00:48.621Z","comments":true,"path":"2018/08/21/2018-08-21_Python实现ssh登录/","link":"","permalink":"http://yoursite.com/2018/08/21/2018-08-21_Python实现ssh登录/","excerpt":"","text":"python实现ssh远程登录123# 测试过程中，比较常用的操作就是将DUT(待测物)接入网络中，然后远程操控对DUT，# 使用SSH远程登陆到主机，然后执行相应的command即可# python 代码如下： 123# paramiko是用python语言写的一个模块，遵循SSH2协议，支持以加密和认证的方式，进行远程服务器的连接# 首先第一步我们需要安装paramiko这个包# 安装命令：pip install paramiko 12# 导入paramiko包import paramiko 1234567s = paramiko.SSHClient() s.set_missing_host_key_policy(paramiko.AutoAddPolicy()) # 允许连接不在know_hosts文件中的主机ssh.connect(\"某IP地址\",22,\"用户名\", \"口令\") execmd = 'pwd' #需要输入的命令stdin, stdout, stderr = s.exec_command (execmd) print(stdout.read()) s.close() b&apos;/home/usra\\n&apos;","categories":[],"tags":[]},{"title":"","slug":"2018-07-29_数据可视化方法","date":"2018-07-29T02:08:08.725Z","updated":"2018-07-29T02:06:06.000Z","comments":true,"path":"2018/07/29/2018-07-29_数据可视化方法/","link":"","permalink":"http://yoursite.com/2018/07/29/2018-07-29_数据可视化方法/","excerpt":"","text":"数据可视化方法1.画折线图1234567891011# 两条折现图import pylab as plimport numpy as nppl.rcParams['font.sans-serif'] = ['SimHei']#解决中文乱码问题x=[1,2,3,4,5]y=[0.1,0.70,0.65,0.78,0.98]z=[0.2,0.40,0.95,0.71,0.78]pl.plot(x,y,label='准确率',c=u'g',marker=u'o') #简单的折线图pl.plot(x,z,label='准确率2',c=u'b',marker=u'p')pl.legend()#legend 图例就是为了帮我们展示出每个数据对应的图像名称. 更好的让读者认识到你的数据结构pl.show() 1234567x=[1,2,3,4,5]y=[0.1,0.70,0.65,0.78,0.98]a=np.arange(0,2*np.pi,0.1)b=np.cos(a)pl.scatter(x,y,s=200,c=u'r',marker=u'o')#绘制散点图pl.scatter(a,b)pl.show()","categories":[],"tags":[]},{"title":"","slug":"Untitled5/Untitled5","date":"2018-07-29T02:07:06.363Z","updated":"2018-07-29T02:06:06.000Z","comments":true,"path":"2018/07/29/Untitled5/Untitled5/","link":"","permalink":"http://yoursite.com/2018/07/29/Untitled5/Untitled5/","excerpt":"","text":"数据可视化方法1.画折线图1234567891011# 两条折现图import pylab as plimport numpy as nppl.rcParams['font.sans-serif'] = ['SimHei']#解决中文乱码问题x=[1,2,3,4,5]y=[0.1,0.70,0.65,0.78,0.98]z=[0.2,0.40,0.95,0.71,0.78]pl.plot(x,y,label='准确率',c=u'g',marker=u'o') #简单的折线图pl.plot(x,z,label='准确率2',c=u'b',marker=u'p')pl.legend()#legend 图例就是为了帮我们展示出每个数据对应的图像名称. 更好的让读者认识到你的数据结构pl.show() 1234567x=[1,2,3,4,5]y=[0.1,0.70,0.65,0.78,0.98]a=np.arange(0,2*np.pi,0.1)b=np.cos(a)pl.scatter(x,y,s=200,c=u'r',marker=u'o')#绘制散点图pl.scatter(a,b)pl.show()","categories":[],"tags":[]},{"title":"frame buffer简单应用","slug":"2018-07-28framebuffer简单应用","date":"2018-07-27T16:01:39.348Z","updated":"2018-07-29T01:22:37.711Z","comments":true,"path":"2018/07/28/2018-07-28framebuffer简单应用/","link":"","permalink":"http://yoursite.com/2018/07/28/2018-07-28framebuffer简单应用/","excerpt":"","text":"现在我们要在LCD上画一个点，我们无法直接对LCD屏进行操作。这时候就需要用到FrameBuffer,Linux可以FrameBuffer这个设备来供用户态进程实现直接写屏。首先我们先简单看一下linux的架构图： 用户程序无法直接操作硬件，frame buffer相当于一个中间人，接受用户程序送过来的数据，然后把数据显示在LCD上。注：framebuffer的设备文件一般是 /dev/fb0、/dev/fb1等，所有的这些操作，都是在控制台界面下，root登录可参考下列链接：http://www.wxtlife.com/2017/06/07/Android-framebuffer/","categories":[],"tags":[]},{"title":"Python批量修改寄存器的值","slug":"2018-07-21_Python批量修改寄存器的值","date":"2018-07-21T04:54:44.602Z","updated":"2018-07-21T04:59:39.349Z","comments":true,"path":"2018/07/21/2018-07-21_Python批量修改寄存器的值/","link":"","permalink":"http://yoursite.com/2018/07/21/2018-07-21_Python批量修改寄存器的值/","excerpt":"","text":"Python批量修改寄存器的值1234567891011121314151617181920# 在写代码过程中，我们修改代码中寄存器的值，但是有时寄存器的数据较多，手动修改容易出现错误而且花费的时间长# 这是一段寄存器的配置值：# 0x00, 0x34# 0x35, 0x25# 0x10, 0xd4# 0xf5, 0xa5# 0x00, 0x34# 0x3a, 0xff# 0x00, 0x00# 0x34, 0x25# 这是要修改代码的值：# &#123;Data, 0x21, 0x23&#125;,# &#123;Data, 0x34, 0x23&#125;,# &#123;Data, 0xd1, 0x2a&#125;,# &#123;Data, 0xe1, 0xc3&#125;,# &#123;Data, 0x00, 0xff&#125;,# &#123;Data, 0xef, 0x23&#125;,# &#123;Data, 0xac, 0x00&#125;,# &#123;Data, 0x25, 0x87&#125;,# 首先将要修改的代码值存在test1.txt中，寄存器的配置值存在test2.txt中 1234# Python实现的过程# 引入必要的包import numpy as npimport pandas as pd 123456789101112#导入代码data = pd.read_csv(\"G:/Test/test1.txt\", header=None)# data# 0 1 2 3# 0 &#123;Data 0x21 0x23&#125; NaN# 1 &#123;Data 0x34 0x23&#125; NaN# 2 &#123;Data 0xd1 0x2a&#125; NaN# 3 &#123;Data 0xe1 0xc3&#125; NaN# 4 &#123;Data 0x00 0xff&#125; NaN# 5 &#123;Data 0xef 0x23&#125; NaN# 6 &#123;Data 0xac 0x00&#125; NaN# 7 &#123;Data 0x25 0x87&#125; NaN 123456789101112#导入寄存器配置值reg = pd.read_csv(\"G:/Test/test2.txt\", header = None)# reg# 0 1# 0 0x00 0x34# 1 0x35 0x25# 2 0x10 0xd4# 3 0xf5 0xa5# 4 0x00 0x34# 5 0x3a 0xff# 6 0x00 0x00# 7 0x34 0x25 12# 修改代码第二列值data[1] = reg[0] 12# 因为代码里面第三列除了数值还有“&#125;”data[2] = reg[1] + \"&#125;\" 1234567891011# 修改之后的代码数据# data# 0 1 2 3# 0 &#123;Data 0x00 0x34&#125; NaN# 1 &#123;Data 0x35 0x25&#125; NaN# 2 &#123;Data 0x10 0xd4&#125; NaN# 3 &#123;Data 0xf5 0xa5&#125; NaN# 4 &#123;Data 0x00 0x34&#125; NaN# 5 &#123;Data 0x3a 0xff&#125; NaN# 6 &#123;Data 0x00 0x00&#125; NaN# 7 &#123;Data 0x34 0x25&#125; NaN 12# 把修改之后的代码保存成txt文件data.to_csv(\"G:/Test/result.txt\",header = None, index = None)","categories":[],"tags":[]},{"title":"Basic Syntax [基本語法]-習題","slug":"2018-07-19_Python_ch2","date":"2018-07-19T16:10:03.271Z","updated":"2018-07-19T16:11:23.883Z","comments":true,"path":"2018/07/20/2018-07-19_Python_ch2/","link":"","permalink":"http://yoursite.com/2018/07/20/2018-07-19_Python_ch2/","excerpt":"","text":"Basic Syntax [基本語法]-習題1234567891011# 習題1# 請輸出以下詩 並利用\"\\t\"與\"\\n\"# &gt;&gt;&gt;# 登幽州臺歌 陳子昂# 前不見古人 後不見來者# 念天地之悠悠 獨愴然而涕下# &gt;&gt;&gt;print(\"登幽州臺歌\\t陳子昂\\n\")print(\"前不見古人\\t後不見來者\")print(\"念天地之悠悠\\t獨愴然而涕下\") 登幽州臺歌 陳子昂 前不見古人 後不見來者 念天地之悠悠 獨愴然而涕下 12345678910111213141516171819# 習題2# 請撰寫一程式，讓使用者可以分別輸入2位同學的名稱及分數，輸出結果並如下排列： (斜體部分為執行程式時輸入)# &gt;&gt;&gt;# 請輸入A同學姓名:Name_A# 請輸入A同學分數:90# 請輸入B同學姓名:Name_B# 請輸入B同學分數:80# 姓名 分數# Name_A 90# Name_B 80# &gt;&gt;&gt;a1 = input(\"请输入A同学的名字：\")a2 = int(input(\"请输入A同学分数：\"))b1 = input(\"请输入B同学的名字：\")b2 = int(input(\"请输入B同学分数：\"))print(\"姓名\\t分数\")print(\"&#123;&#125;\\t&#123;&#125;\".format(a1,a2))print(\"&#123;&#125;\\t&#123;&#125;\".format(b1,b2)) 请输入A同学的名字：Name_A 请输入A同学分数：90 请输入B同学的名字：Name_B 请输入B同学分数：80 姓名 分数 Name_A 90 Name_B 80","categories":[],"tags":[]},{"title":"","slug":"第一章Python3和Python2的区别","date":"2018-07-17T15:14:58.357Z","updated":"2018-06-28T15:21:52.980Z","comments":true,"path":"2018/07/17/第一章Python3和Python2的区别/","link":"","permalink":"http://yoursite.com/2018/07/17/第一章Python3和Python2的区别/","excerpt":"","text":"12345# 1-中文支持问题#py2对中文等多字符集语言支持不好，比如不能用中文名坐变量，而且如果代码中有中文，必须在第一行加上下面这一行# -*- coding: utf-8 -*-变量=100变量 100 123# 2-print的用法x=100print(x) # py2中为print x 100 12345# 3-py3中基本类型也被归为类，即一切都是类i=1f=1.0s='str'type(i),type(f),type(s) (int, float, str) 123456# 4-字典的keys等操作返回的不再是list二是dict_keys等类型dict1=&#123;'name':'黎明','age':50&#125;keys=dict1.keys()# py2中type(keys)为list而不是py3返回的dict_keys,后者称为键视图对象，是一个类似集合的对象，其中键元素是唯一的且可哈希keys,type(keys) #help(dict1.keys) Help on built-in function keys: keys(...) method of builtins.dict instance D.keys() -&gt; a set-like object providing a view on D&apos;s keys 123456# 5-map/filter/zip函数作用于列表后的返回值是迭代器，而不再是py2的列表def func(x): return x*xlist1=[1,2,3,4,5]itor = map(func,list1)#注意py3的map函数返回的是迭代器而不再是py2的列表list(itor) #因此通常需要用list函数用返回的迭代器再生成列表 [1, 4, 9, 16, 25] 123# 6-比较运算符等有变化3 != 4 #py2写成 3 &lt;&gt; 4 #不等号的写法1 &lt; 'c' #数字与字符无法比较，py3会抛出异常，但py2返回True或False（按照ASCII码表顺序） --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-28-51a6c50e6149&gt; in &lt;module&gt;() 1 # 6-比较运算符等有变化 2 3 != 4 #py2写成 3 &lt;&gt; 4 #不等号的写法 ----&gt; 3 1 &lt; &apos;c&apos; #数字与字符无法比较，py3会抛出异常，但py2返回True或False（按照ASCII码表顺序） TypeError: &apos;&lt;&apos; not supported between instances of &apos;int&apos; and &apos;str&apos; 123# 7-整数类型和除法#long1 = 345L #py3不再支持用后缀l或L表示长整数5/3 , 5//3 #py3中除法取整要用// (1.6666666666666667, 1) 123# 8-py3字符串默认为双字节Unicodeu'String1' #u可以省略了type(b'byteStrings')#字符串前缀“b”或“B”表示二进制字符串，其类型为bytes bytes 123# 9-取消了file数据类型f = open('test.txt','w')type(f) #py3中open方法为_io.TextIOWrapper的对象，而py2返回file类型对象 _io.TextIOWrapper 12345# 10-异常处理的改变try: raise TypeError('错误类型是：类型错误')except TypeError as err: print(err) 错误类型是：类型错误 12345678910加入了键词加入“as”和“with”。增加了常量“True”“False”和“None”。加入nonlocal语句。使用noclocal x声明x为函数外部的变量。删除了raw_input()，用input()代替。去除元组参数解包。不能像def(a, (b, c)):pass这样定义函数了。增加了2进制字面量，如 '0b110110110'。bin()函数可返回整数的2进制字符串。扩展的可迭代解包。在Python 3.X 里，“a, b, *x = seq”和“*x, a = seq”都是合法的，只要求两点“x”是list。对象和“seq”是可迭代的。面向对象引入了抽象基类。类的迭代器方法next()改名为__next__()，并增加内置函数next()，用以调用迭代器的__next__()方法。","categories":[],"tags":[]},{"title":"Linux常用命令","slug":"2018-05-31_linux_command","date":"2018-05-31T15:39:17.754Z","updated":"2018-05-31T15:39:17.755Z","comments":true,"path":"2018/05/31/2018-05-31_linux_command/","link":"","permalink":"http://yoursite.com/2018/05/31/2018-05-31_linux_command/","excerpt":"","text":"近段时间开始接触linux，在此记录一些常用的linux命令。 cp 用于复制文件和目录语法： cp [options] sourcedir destdir参数说明：–a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。–d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。-f：覆盖已经存在的目标文件而不给出提示。-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。-l：不复制文件，只是生成链接文件。","categories":[],"tags":[]},{"title":"Vim使用","slug":"2018-05-29_vim","date":"2018-05-28T16:06:12.327Z","updated":"2018-07-17T15:04:09.580Z","comments":true,"path":"2018/05/29/2018-05-29_vim/","link":"","permalink":"http://yoursite.com/2018/05/29/2018-05-29_vim/","excerpt":"","text":"VIM是Linux下面自带的文本编辑器，用处广泛，但是比较难学。本文记录使用vim过程常用的命令，遇到的问题和使用心得。 Ubuntu上的vim ubuntu上,缺省安装的是不完全的vim，在输入模式（Insert mode）使用方向键会出现A,B,C,D。 解决方法：安装完全的vim,命令：1.sudo apt-get update 2.sudo apt-get install vim vim介绍基本上 vi 共分为三种模式，分别是『一般模式』、『编辑模式』与『指令列命令模式』。 这三种模式的作用分别是： 一般模式：以 vi 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、贴上』来处理你的文件数据。 编辑模式：在一般模式中可以进行删除、复制、贴上等等的动作，但是却无法编辑文件内容的！ 要等到你按下『i, I, o, O, a, A, r, R』等任何一个字母之后才会进入编辑模式。注意了！通常在 Linux 中，按下这些按键时，在画面的左下方会出现『 INSERT 或 REPLACE 』的字样，此时才可以进行编辑。而如果要回到一般模式时， 则必须要按下『Esc』这个按键即可退出编辑模式。 指令列命令模式：在一般模式当中，输入『 : / ? 』三个中的任何一个按钮，就可以将光标移动到最底下那一行。在这个模式当中， 可以提供你『搜寻资料』的动作，而读取、存盘、大量取代字符、离开 vi 、显示行号等等的动作则是在此模式中达成的！ 简单的说，我们可以将这三个模式想成底下的图标来表示：一般模式可与编辑模式及指令列模式切换， 但编辑模式与指令列模式之间不可互相切换(此段出处http://cn.linux.vbird.org/linux_basic/0310vi.php) Vim常用命令移动光标的方法 [Ctrl] + [f]：屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b]：屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) 0 或功能键[Home]：这是数字『 0 』：移动到这一行的最前面字符处 (常用) $ 或功能键[End]：移动到这一行的最后面字符处(常用) G： 移动到这个档案的最后一行(常用) gg： 移动到这个档案的第一行，相当于 1G 啊！ (常用) n：n 为数字。光标向下移动 n 行(常用)搜寻与取代 /word：向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) :n1,n2s/word1/word2/g：n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：『:100,200s/vbird/VBIRD/g』。(常用) :1,$s/word1/word2/g：从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) :1,$s/word1/word2/gc：从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)删除、复制与贴上 x, X：在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) dd：删除游标所在的那一整列(常用) ndd：n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列 (常用) yy：复制游标所在的那一行(常用) nyy：n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列(常用) p, P：p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) u：复原前一个动作。(常用) [Ctrl]+r：重做上一个动作。(常用) . :不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)","categories":[],"tags":[]},{"title":"MTF测试图卡规格","slug":"2018-05-28_MTF_Chart_Size","date":"2018-05-28T12:14:35.310Z","updated":"2018-05-29T15:36:51.017Z","comments":true,"path":"2018/05/28/2018-05-28_MTF_Chart_Size/","link":"","permalink":"http://yoursite.com/2018/05/28/2018-05-28_MTF_Chart_Size/","excerpt":"","text":"1.Imatest Chart Finder计算图卡大小测试camera MTF时，需要知道所需要的图卡的大小，Imatest提供了一个网页，只要输入sensor的像素，镜头的视场角，还有镜头到图卡的距离就可以得出图卡的大小。网页链接Imatest Chart Finder。下图为两百万像素sensor，和视场角为74.5度的镜头，最小物距为0.5m的摄像头模组所需的图卡大小为66.28cm*37.28cm 2.通过像素尺寸（Pixel size），对焦距离，焦距（EFL）计算图卡尺寸根据成像原理可得下图，上面的焦点与被摄物体形成的三角形，下面是焦点与图像传感器形成的三角形，两个三角形相似。这样就可以求出Y值。则图卡的宽度就等于sensor宽度像素点数目乘上Y值，图卡的宽度就等于sensor的长度像素点乘上Y值。 5/29/2018 11:36:25 PM 写的有点乱~","categories":[],"tags":[]},{"title":"研究Camera需要学习的知识","slug":"2018-05-26_camera_base_knowledge","date":"2018-05-26T07:51:50.024Z","updated":"2018-05-27T00:47:43.660Z","comments":true,"path":"2018/05/26/2018-05-26_camera_base_knowledge/","link":"","permalink":"http://yoursite.com/2018/05/26/2018-05-26_camera_base_knowledge/","excerpt":"","text":"数字成像系统 人眼是性能优良的成像系统，数字成像系统就是模仿人眼，将自然界的中光信号转换成电信号，然后将模拟电信号转换成数字信号的过程。camera就是典型数字成像系统，典型的成像系统如下图：camera是典型数字成像系统，要对camera有深入的了解，大概需要掌握以下几方面的知识： 光学 颜色科学 CMOS/CCD image sensor ISP 数字图像处理 当然，camera的光圈和调焦还会涉及机械和电路方面的知识。本博客会根据以上四个方面陆续更新与camera有关的知识。","categories":[],"tags":[]},{"title":"软件测试基本知识","slug":"2018-05-26_Solfware_Test","date":"2018-05-26T00:30:32.422Z","updated":"2018-05-26T12:06:49.374Z","comments":true,"path":"2018/05/26/2018-05-26_Solfware_Test/","link":"","permalink":"http://yoursite.com/2018/05/26/2018-05-26_Solfware_Test/","excerpt":"","text":"软件测试测试模式 传统的瀑布模型 常用W模型 测试过程 单元测试 -&gt; 集成测试 -&gt; 确认测试 -&gt; 系统测试 -&gt; 验收测试 软件测试方法分为白盒测试和黑盒测试 黑盒测试:软件测试以黑盒测试为主，黑盒测试安装需求进行功能测试，黑盒测试还可以分为功能测试和非功能测试。非功能测试有强度测试，性能测试，安全测试，相容性测试等。功能测试方法有等价类划分法（把无限的范围变为有限的），边界值划分法，错误推测法，因果图法，决策法，场景法。 白盒测试：主要是对软件代码进行测试，通常需要掌握一定的编码知识。常用的方法有程序插椿法，逻辑覆盖法，基本路径测试法等。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-03-24T16:23:19.075Z","updated":"2018-03-24T16:23:19.075Z","comments":true,"path":"2018/03/25/hello-world/","link":"","permalink":"http://yoursite.com/2018/03/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}