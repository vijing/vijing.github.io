{"meta":{"title":"MY BLOG","subtitle":"You cannot alter your fate.However,you can rise to meet it if you choose","description":"每天进步一点点，人生精彩无极限。","author":"vijing","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"camera测试之颜色还原","slug":"2018-10-15_camera测试之颜色还原","date":"2018-10-15T13:23:20.817Z","updated":"2018-10-15T13:30:51.712Z","comments":true,"path":"2018/10/15/2018-10-15_camera测试之颜色还原/","link":"","permalink":"http://yoursite.com/2018/10/15/2018-10-15_camera测试之颜色还原/","excerpt":"","text":"标签（空格分隔）： camera测试 工作总结测试目的： camera对色彩的还原能力测试主要设备： 24色色卡，灯箱测试环境： 1.D65/CW/A光源，照度为600±100lux,整个chart表面的亮度值相差小于10%2.D65光源，照度为20lux,整个chart的表面的亮度相差小于15%测试注意事项： 24色卡位于预览画面的中心，大小占整个画面的70%测试原理：在硬件电子系统中，也就是我们的摄像头，屏幕中，是使用RGB颜色模型来表示的。但是RGB颜色模型中颜色发生变化过程和人眼对颜色的感应过程不一致。简单来说，对RGB颜色模型来说，假设是8bit的颜色深度，当R颜色通道从0增大到10和从240增大到250，其实对于R颜色通道来说，它们的增量大小是一样的。但是对于人眼来说，从当R颜色通道从0增大到10时，人眼能明显看到他们的变化，但是当R颜色通道从240增大到250时，人眼基本上看不出颜色的变化。所以RGB颜色模型不适合用于色彩还原的测试。先简单介绍一下CIELAB颜色模型，CIELAB颜色模型表示为（L,a,b）,L用于表示明亮度（Luminance）,也是是黑色到白色的变化的位置，范围0～100。a和b表示颜色的变化，a为绿色（green）到紫红色（magenta）间的变化，b表示蓝色（blue）到黄色（yellow）间的变化，范围额-128到+127。3D图如下图所示，其中距离圆心越进饱和度越低。对于CIELAB颜色模型，当a从0变化到10和从100变化到110时，人眼能够感觉到一样的颜色变化。也就是说CIELAB的L,a,b的变化量一样，则人眼感受到的颜色变化是一样的。上面所说的就是CIELAB颜色模型具有视觉上的均匀性（perceptually uniform）,所以使用CIELAB颜色模型用于camera颜色还原的测试。RGB颜色模型转CIELAB颜色模型过程：首先先将RGB颜色模型转成CIEXYZ颜色模型，然后CIEXYZ颜色模型再转换成CIELAB颜色模型。具体转换公式如下：RGB &gt;&gt; CIELABCIEXYZ &gt;&gt; CIELAB其中X n ，Y n ，Z n一般默認是95.047，100.0，108.883。下一步基于CIELAB颜色模型计算颜色误差和颜色的饱和度（saturation），如下图所示：用ΔC，ΔE表示色彩正确度误差，如上图所示，左图表示CIELAB颜色模型，右图表示CIELAB颜色模型的一个切面圆。ΔC就是平面圆上两个点的距离。ΔE计算色度差（C）外，还加入明度差。也就是说ΔE表示空间上两个点的距离。一般而言ΔC，ΔE值越小表示越接近真实颜色SRGB，也表示摄像模组的颜色误差越小，颜色越好。ΔC，ΔE计算公式如下：另外一个测量量就是颜色的饱和度，饱和度指色彩的纯洁性，也叫饱和度或彩度。简单来说，就是颜色越接近黑色或者白色，则饱和度越低。对应到上图的切面圆来说，越靠近圆心则饱和度越低，越靠近圆环饱和度月高。饱和度计算公式如下： 判断标准： 算法系统框图：","categories":[],"tags":[]},{"title":"Camera MTF测试","slug":"2018-10-14_Camera MTF测试","date":"2018-10-13T17:52:46.893Z","updated":"2018-10-15T13:13:38.575Z","comments":true,"path":"2018/10/14/2018-10-14_Camera MTF测试/","link":"","permalink":"http://yoursite.com/2018/10/14/2018-10-14_Camera MTF测试/","excerpt":"","text":"标签（空格分隔）： camera测试 工作总结 1.MTF介绍MTF（Modulation Transfer Function）模量传递函数。MTF是camera成像对比度和分辨率的综合表现。MTF反映的是镜头对被拍摄物体的再现能力。从另一个角度来看，camera成像过程可以简单看成下图：简单来，物体经过camera系统之后形成图象。我们用Io表示物体表面的最大亮度与最小亮度的差，Ii表示图象最大亮度与最小亮度之差。那么MTF表征的量就是Ii/Io,如果是理想情况下，Ii等于Io, MTF的值就是等于1，但是在实际的成像系统中，这个是不可能发生的。同样的，在成像系统中，Ii的值不可能为0。所以说，MTF的值的范围为0～1. 2.camera MTF测试方法一般来说，MTF测试的方法分为： 1.用人眼来看，人眼来看的方法就是camera拍摄12233 chart得到的图片中的黑白线对，看人眼可以辨识黑白线对的极限。这部分就不具体介绍了。 2.按照MTF的定义也就是最大亮度值减最小亮度值的差来求camera的MTF值。 具体如下：使用上图做为camera拍摄的图卡，其中图中灰色部分为灰度值为0和灰度值为255的象素点间隔组成的图象。然后取红框部分区域进行计算，红框大小可根据实际情况来取。计算公式：$$(Lmax-Lmin)/(Lmax+Lmin)$$，其中L为灰度值。通过这个公司就可以求出五个区域的MTF值。这种方法算法实现简单，但是误差会比较大。 3.SFR方法SFR(spatial frequency response)空间频率响是MTF的一种测试算法。 这次先简单介绍一下SFR的流程和怎样在Matheamtica实现，以后有时间再具体介绍其中的原理。。。。未完成","categories":[],"tags":[]},{"title":"CCD和CMOS的区别","slug":"title_ CCD和CMOS的区别","date":"2018-10-13T07:50:24.353Z","updated":"2018-10-13T07:49:42.082Z","comments":true,"path":"2018/10/13/title_ CCD和CMOS的区别/","link":"","permalink":"http://yoursite.com/2018/10/13/title_ CCD和CMOS的区别/","excerpt":"","text":"标签（空格分隔）： camera，原创总结 图像传感器（image sensor）是将光信号转换成电信号的器件。常见的类型可分为CCD和CMOS，今天我们就聊聊CCD和CMOS的区别和联系。首先，我们先了解一下什么是CCD和CMOS,CCD（charge-coupled device）就是感光耦合元件，CMOS（CMOS Active pixel sensor）互补式金属氧化物半导体有源像素传感器（CMOS Active pixel sensor）。按照我的理解，CCD和CMOS的结构不同是CCD和CMOS有明显区别的根本原因。我们将sensor将光信号转换成电信号的过程比喻成在下雨天时我们要存储雨水的过程。要存储1平方米区域内天下落下的雨水，对于CCD，存储雨水的方法用一个长宽为1m的桶去接水；而对于CMOS，存储雨水的方法就是使用100个长宽为0.01m的小桶排成1平方米大小的区域去接水。根据这样的结构，我们可以简单分析一下CCD和CMOS的区别。能够使用长宽为1m的桶的都是大户人家（CCD更贵，一般用于高档相机），而且要一次搬完长宽为1m桶的水（只需要一次放大）,需要更多的人力（更耗电）。但是大桶可以存储更多的水（CCD的成像质量更好）。与之对应，CMOS工艺要求没有CCD高，会比较便宜，一般用于低端产品。而且CMOS有数以百万的放大器的不一致性却带来了更高的固定噪声，是CMOS相对CCD的固有劣势。","categories":[],"tags":[]},{"title":"电子制造业常用英语","slug":"title_ 电子制造业常用英语","date":"2018-10-13T07:50:24.350Z","updated":"2018-10-13T07:48:46.990Z","comments":true,"path":"2018/10/13/title_ 电子制造业常用英语/","link":"","permalink":"http://yoursite.com/2018/10/13/title_ 电子制造业常用英语/","excerpt":"","text":"标签（空格分隔）： 英语 刚开始进入电子制造业时，经常用到一些英语的专用名词，此处进行简单的总结 EMS: Electronics Manufacturing Service,电子产品制造服务.OEM: Original Equipment Manufacturer 原始设备制造商。OEM是指客户设计，制造商生产。ODM：Original Design Manufacturer 原始设计制造商。 ODM狮子制造商既负责设计，又负责生产。JDM: Joint Design Manufacturer 协同设计制造商。JDM是介于ODM和OEM之间的一种协同设计生产的模式，客户和制造商通常一起设计产品，但生产通常由制造商来完成。CCEM/CM : Contract Manufacturer,合约制造商,CEM或CM是合约制造的承办方，即俗称的代工或贴牌","categories":[],"tags":[]},{"title":"Camera测试之Color & Lens shading Test","slug":"2018-10-13_Camera测试之Color & Lens shading Test","date":"2018-10-13T03:19:26.211Z","updated":"2018-10-13T03:41:28.699Z","comments":true,"path":"2018/10/13/2018-10-13_Camera测试之Color & Lens shading Test/","link":"","permalink":"http://yoursite.com/2018/10/13/2018-10-13_Camera测试之Color & Lens shading Test/","excerpt":"","text":"标签： 原创 工作总结 测试目的：测试摄像头成像的均匀性测试主要设备：均匀光源（DNP灯箱），色温照度计测试环境：将灯箱光源调至600±100lux测试注意事项：保证均匀的光源测试原理：造成摄像头成像不均匀的原因有两个：1.摄像头成像原理是透镜成像，光线透过透镜中心和透过透镜边缘会有不同的折射，所以会导致lens shading。不同波长的光折射率不一样，所以会导致color shading。2.镜头CRA(chief ray angle)和Sensor CRA不匹配也会导致color&amp;lens shading。下面分别介绍Lens shading和colorshading的测试方法和原理。Color&amp;Lensshading测试时会先让camera在拍摄白板或者拍摄灰卡得到图片。 一.Lens shading测试原理如上图所示，测试Lens shading时，取camera拍摄白板或者拍摄灰卡得到的图片中心和四周区域3232或者100100（一般会选择图片长宽的1/20），1.分别计算每个区域的平均灰度值2.然后将四个角四个区域的平均灰度值除以中心区域的平均灰度值3.将第二步计算结果拿去判断Pass or fail 二．Color shading测试原理：Color shading测试原理与lens shading测试很相似，也是先取camera拍摄白板或者拍摄灰卡得到的图片中心和四周区域3232或者100100（一般会选择图片长宽的1/20）1.分别计算每个区域的平均R,G,B的值2.分别计算每个区域的 平均R值/平均G值 平均B值/平均G值将四角四个区域的 平均R值/平均G值 平均B值/平均G值 除以中心区域的 平均R值/平均G值 平均B值/平均G值 判断标准：一般来说，Lens shading测试结果Pass的标准为0.85~1.15。Color shading测试结果为Pass的标准为0.95~1.05。","categories":[],"tags":[]},{"title":"Color&Lens shading测试图卡位置检测","slug":"2018-10-13_Color&Lens shading测试图卡位置检测","date":"2018-10-13T03:14:44.318Z","updated":"2018-10-13T03:31:51.189Z","comments":true,"path":"2018/10/13/2018-10-13_Color&Lens shading测试图卡位置检测/","link":"","permalink":"http://yoursite.com/2018/10/13/2018-10-13_Color&Lens shading测试图卡位置检测/","excerpt":"","text":"标签（空格分隔）： 原创 工作总结 进行测试之前，最重要的一步就是确保测试环境是正常的。对于camera测试来说，测试之前很重要的一步就是要确保camera和图卡的位置是正确的。在实际产测中，如果每个DUT测试之前都需要人去确认camera和图卡的位置是否符合要求，则会消耗大量的人力物力。所以需要写一个程序在开始测试之前判断camera和图卡的位置是否正确，如果正确则开始测试。如果错误则停止测试。因为在同一个工站可能会测试camera的两个测试项，例如同时测试camera的MTF和Color&amp;Lensshading。这样的话测试过程中则需要转换图卡。转换图卡的过程中可能会出现错误意外。首先我们先分析一下图卡切换到位和切换不到位情况拍摄的图片有什么不同。图卡位置正确图卡位置正确灰度直方图图卡位置错误图卡位置错误灰度直方图 图卡位置正确和图卡位置错误灰度值灰度直方图分布有差异，可用一阈值进行二值化处理流程如下： 处理流程图 根据上图的处理流程之后，就可以判断camera和图卡的位置是否正确。","categories":[],"tags":[]},{"title":"英语简单句类型","slug":"2018-09-28_英语简单句类型","date":"2018-09-27T15:59:43.442Z","updated":"2018-09-27T16:12:17.810Z","comments":true,"path":"2018/09/27/2018-09-28_英语简单句类型/","link":"","permalink":"http://yoursite.com/2018/09/27/2018-09-28_英语简单句类型/","excerpt":"","text":"标签（空格分隔）： 英语 类型1 主语 + 系动词 + 表语 系动词 例子 系动词 be 与感官有关 look,smell, sound, feel, taste 与保持有关 keep, remain, stay, stand, lie… 与变化有关 get, become, turn, go, grow, fall, come.. 类型2 主语 + 谓语由“主语 + 不及物动（SVi）”构成主谓系统。不及物动词后面要加上介词才能接跟宾语，所以叫不及物动词。理论上说，“主语+不及物动词”就可以构成正确的句子，已过加上次要的附属结构，有下面几种情况： 句型变化 例子 SVi + 介词 + 宾语 He arrived at the factory SVi + 副词 He arrived soon SVi + to do… He came to see his mother 特殊词 + Vi + S(名词.) Here comes the bus 类型3 主语 + 谓语 + 宾语由“主语 + 及物动词 + 宾语”（SVO）构成主谓系统。及物动词后面马上跟宾语，不需要在动宾之间加上介词，所以叫及物动词。 SVt + 名/代 + （介宾） SVt + 非谓语形式 SVt +(to+sb/sth）+从句 类型4 主语 + 谓语 + 间接宾语 + 直接宾语 句型变化 同类词 例句 SVt +直宾 + to + 间宾 afford, lend, leave, hand, offer, owe, 等等 The teacher gave a book to me/the boy SVt +直宾 + for + 间宾 Buy, call, cook, choose, do, draw, find, get, make,等等 My mother cooked a mal for me/her son SVt + 间宾 + 复合不定式直宾/从句直宾 包括前面两类动词 The teacher gave me/the boy a book SVt + 间宾 + 复合不定式直宾/从句直宾 learn, teach, show, tell, point out He showed me how to swim. （复合不定式充当直接宾语）He told me where I should go.（从句充当直接宾语）He told me that the news was true. （从句充当直接宾语） SVt +to +间宾 +从句直宾 suggest, reply,explain, point out等等 He replied to me that the news was true. （从句充当直接宾语） 类型5 主语 + 谓语 + 宾语 + 宾补 SVt + 宾语 + 形/副/介/名 SVt + 宾语+非谓语形式 SVt + it + 形/名+ to do SVt + it + 形/名/介宾 + 从句","categories":[],"tags":[]},{"title":"颜色空间","slug":"2018-09-19Color_Space","date":"2018-09-19T15:54:31.684Z","updated":"2018-10-13T05:52:07.352Z","comments":true,"path":"2018/09/19/2018-09-19Color_Space/","link":"","permalink":"http://yoursite.com/2018/09/19/2018-09-19Color_Space/","excerpt":"","text":"标签（空格分隔）： 转载学习 学习总结 图像处理 颜色空间我们经常看到RGB,YUV,HSL,Lab等这些名词来描述颜色，那么这些名词之间有怎样的具体又是指什么东西呢？RGB,CMYK,HSL,Lab,YUV这些属于颜色空间，颜色空间，简单来说就是颜色在不同的应用场景和应用背景的表示方式。 RGBRGB主要应用于显示器系统，彩色阴极射线管,彩色光栅图形的显示器，也就是说RGB面向硬件。RGB又分为Adobe RGB和sRGB,AdobeRGB能表示的范围要大一些。就是说如果你使用8位JPG文件，你最好使用sRGB。如果你使用16位文件，可能选择Adobe RGB更合适。 CMYKCMYK(cyan,magenta,yellow)颜色空间应用于印刷工业,印刷业通过青(C)、品(M)、黄(Y)三原色油墨的不同 网点面积率的叠印来表现丰富多彩的颜色和阶调，这便是三原色的CMY颜色空间。实际印刷中，一般采用青 (C)、品(M)、黄(Y)、黑(BK)四色印刷，在印刷的中间调至暗调增加黑版。 HSVRGB和CMY颜色模型都是面向硬件的，而HSV（Hue Saturation Value）颜色模型是面向用户的。这个模型中颜色的参数分别是：色调（H：hue），饱和度（S：saturation），亮度（V：value）。这是根据人观察色彩的生理特征而提出的颜色模型（人的视觉系统对亮度的敏感度要强于色彩值，这也是为什么计算机视觉中通常使用灰度即亮度图像来处理的原因之一） HSV模型的三维表示从RGB立方体演化而来。设想从RGB沿立方体对角线的白色顶点向黑色顶点观察，就可以看到立方体的六边形外形。六边形边界表示色彩，水平轴表示纯度，明度沿垂直轴测量。与加法减法混色的术语相比，使用色相，饱和度等概念描述色彩更自然直观。 LabLab颜色被设计来接近人类视觉。它致力于感知均匀性，它的L分量密切匹配人类亮度感知。因此可以被用来通过修改a和b分量的输出色阶来做精确的颜色平衡，或使用L分量来调整亮度对比。Lab颜色空间是由CIE(国际照明委员会)制定的一种色彩模式。自然界中任何一点色都可以在Lab空间中表达出来，它的色彩空间比RGB空间还要大。另外，这种模式是以数字化方式来描述人的视觉感应， 与设备无关，所以它弥补了RGB和CMYK模式必须依赖于设备色彩特性的不足。 YUV YUV色彩空间的重要性是它的亮度信号Y和色度信号U、V是分离的。如果只有Y信号分量而没有U、V分量， 那么这样表示的图就是黑白灰度图。彩色电视采用YUV空间正是为了用亮度信号Y解决彩色电视机与黑白电视机 的兼容问题，使黑白电视机也能接收彩色信号。 YUV是通过亮度-色差来描述颜色的颜色空间。 亮度信号经常被称作Y，色度信号是由两个互相独立的信号组成。视颜色系统和格式不同，两种色度信号经常被称作UV或PbPr或CbCr。这些都是由不同的编码格式所产生的，但是实际上，他们的概念基本相同。在DVD中，色度信号被存储成Cb和Cr（C代表颜色，b代表蓝色，r代表红色） YUV颜色空间是从RGB颜色空间推导而来。 RGB和YUV的换算公式如下： Y = 0.299 R&apos; + 0.587 G&apos; + 0.114 B&apos; U = -0.147 R&apos; 0.289 G&apos; + 0.436 B&apos; = 0.492(B&apos;- Y) V = 0.615 R&apos; 0.289 G&apos; + 0.436 B&apos; = 0.877(R&apos;- Y)","categories":[],"tags":[]},{"title":"python实现ssh远程登录","slug":"2018-08-21_Python实现ssh登录","date":"2018-08-21T14:59:26.324Z","updated":"2018-10-13T05:52:41.184Z","comments":true,"path":"2018/08/21/2018-08-21_Python实现ssh登录/","link":"","permalink":"http://yoursite.com/2018/08/21/2018-08-21_Python实现ssh登录/","excerpt":"","text":"标签（空格分隔）： python 实用工具 python实现ssh远程登录123# 测试过程中，比较常用的操作就是将DUT(待测物)接入网络中，然后远程操控对DUT，# 使用SSH远程登陆到主机，然后执行相应的command即可# python 代码如下： 123# paramiko是用python语言写的一个模块，遵循SSH2协议，支持以加密和认证的方式，进行远程服务器的连接# 首先第一步我们需要安装paramiko这个包# 安装命令：pip install paramiko 12# 导入paramiko包import paramiko 1234567s = paramiko.SSHClient() s.set_missing_host_key_policy(paramiko.AutoAddPolicy()) # 允许连接不在know_hosts文件中的主机ssh.connect(\"某IP地址\",22,\"用户名\", \"口令\") execmd = 'pwd' #需要输入的命令stdin, stdout, stderr = s.exec_command (execmd) print(stdout.read()) s.close() b&apos;/home/usra\\n&apos;","categories":[],"tags":[]},{"title":"数据可视化方法","slug":"2018-07-29_数据可视化方法","date":"2018-07-29T02:08:08.725Z","updated":"2018-10-13T05:50:37.568Z","comments":true,"path":"2018/07/29/2018-07-29_数据可视化方法/","link":"","permalink":"http://yoursite.com/2018/07/29/2018-07-29_数据可视化方法/","excerpt":"","text":"标签（空格分隔）： 原创 python 数据分析 1.画折线图1234567891011# 两条折现图import pylab as plimport numpy as nppl.rcParams['font.sans-serif'] = ['SimHei']#解决中文乱码问题x=[1,2,3,4,5]y=[0.1,0.70,0.65,0.78,0.98]z=[0.2,0.40,0.95,0.71,0.78]pl.plot(x,y,label='准确率',c=u'g',marker=u'o') #简单的折线图pl.plot(x,z,label='准确率2',c=u'b',marker=u'p')pl.legend()#legend 图例就是为了帮我们展示出每个数据对应的图像名称. 更好的让读者认识到你的数据结构pl.show() 1234567x=[1,2,3,4,5]y=[0.1,0.70,0.65,0.78,0.98]a=np.arange(0,2*np.pi,0.1)b=np.cos(a)pl.scatter(x,y,s=200,c=u'r',marker=u'o')#绘制散点图pl.scatter(a,b)pl.show()","categories":[],"tags":[]},{"title":"frame buffer简单应用","slug":"2018-07-28_framebuffer简单应用","date":"2018-07-27T16:01:39.348Z","updated":"2018-10-13T05:53:32.724Z","comments":true,"path":"2018/07/28/2018-07-28_framebuffer简单应用/","link":"","permalink":"http://yoursite.com/2018/07/28/2018-07-28_framebuffer简单应用/","excerpt":"","text":"标签（空格分隔）： LCD 现在我们要在LCD上画一个点，我们无法直接对LCD屏进行操作。这时候就需要用到FrameBuffer,Linux可以FrameBuffer这个设备来供用户态进程实现直接写屏。首先我们先简单看一下linux的架构图： 用户程序无法直接操作硬件，frame buffer相当于一个中间人，接受用户程序送过来的数据，然后把数据显示在LCD上。注：framebuffer的设备文件一般是 /dev/fb0、/dev/fb1等，所有的这些操作，都是在控制台界面下，root登录可参考下列链接：http://www.wxtlife.com/2017/06/07/Android-framebuffer/","categories":[],"tags":[]},{"title":"Python批量修改寄存器的值","slug":"2018-07-21_Python批量修改寄存器的值","date":"2018-07-21T04:54:44.602Z","updated":"2018-10-13T05:53:52.760Z","comments":true,"path":"2018/07/21/2018-07-21_Python批量修改寄存器的值/","link":"","permalink":"http://yoursite.com/2018/07/21/2018-07-21_Python批量修改寄存器的值/","excerpt":"","text":"标签（空格分隔）： 原创 工作总结 Python批量修改寄存器的值1234567891011121314151617181920# 在写代码过程中，我们修改代码中寄存器的值，但是有时寄存器的数据较多，手动修改容易出现错误而且花费的时间长# 这是一段寄存器的配置值：# 0x00, 0x34# 0x35, 0x25# 0x10, 0xd4# 0xf5, 0xa5# 0x00, 0x34# 0x3a, 0xff# 0x00, 0x00# 0x34, 0x25# 这是要修改代码的值：# &#123;Data, 0x21, 0x23&#125;,# &#123;Data, 0x34, 0x23&#125;,# &#123;Data, 0xd1, 0x2a&#125;,# &#123;Data, 0xe1, 0xc3&#125;,# &#123;Data, 0x00, 0xff&#125;,# &#123;Data, 0xef, 0x23&#125;,# &#123;Data, 0xac, 0x00&#125;,# &#123;Data, 0x25, 0x87&#125;,# 首先将要修改的代码值存在test1.txt中，寄存器的配置值存在test2.txt中 1234# Python实现的过程# 引入必要的包import numpy as npimport pandas as pd 123456789101112#导入代码data = pd.read_csv(\"G:/Test/test1.txt\", header=None)# data# 0 1 2 3# 0 &#123;Data 0x21 0x23&#125; NaN# 1 &#123;Data 0x34 0x23&#125; NaN# 2 &#123;Data 0xd1 0x2a&#125; NaN# 3 &#123;Data 0xe1 0xc3&#125; NaN# 4 &#123;Data 0x00 0xff&#125; NaN# 5 &#123;Data 0xef 0x23&#125; NaN# 6 &#123;Data 0xac 0x00&#125; NaN# 7 &#123;Data 0x25 0x87&#125; NaN 123456789101112#导入寄存器配置值reg = pd.read_csv(\"G:/Test/test2.txt\", header = None)# reg# 0 1# 0 0x00 0x34# 1 0x35 0x25# 2 0x10 0xd4# 3 0xf5 0xa5# 4 0x00 0x34# 5 0x3a 0xff# 6 0x00 0x00# 7 0x34 0x25 12# 修改代码第二列值data[1] = reg[0] 12# 因为代码里面第三列除了数值还有“&#125;”data[2] = reg[1] + \"&#125;\" 1234567891011# 修改之后的代码数据# data# 0 1 2 3# 0 &#123;Data 0x00 0x34&#125; NaN# 1 &#123;Data 0x35 0x25&#125; NaN# 2 &#123;Data 0x10 0xd4&#125; NaN# 3 &#123;Data 0xf5 0xa5&#125; NaN# 4 &#123;Data 0x00 0x34&#125; NaN# 5 &#123;Data 0x3a 0xff&#125; NaN# 6 &#123;Data 0x00 0x00&#125; NaN# 7 &#123;Data 0x34 0x25&#125; NaN 12# 把修改之后的代码保存成txt文件data.to_csv(\"G:/Test/result.txt\",header = None, index = None)","categories":[],"tags":[]},{"title":"Basic Syntax [基本語法]-習題","slug":"2018-07-19_Python_ch2","date":"2018-07-19T16:10:03.271Z","updated":"2018-10-13T05:54:21.123Z","comments":true,"path":"2018/07/20/2018-07-19_Python_ch2/","link":"","permalink":"http://yoursite.com/2018/07/20/2018-07-19_Python_ch2/","excerpt":"","text":"标签（空格分隔）： python Basic Syntax [基本語法]-習題1234567891011# 習題1# 請輸出以下詩 並利用\"\\t\"與\"\\n\"# &gt;&gt;&gt;# 登幽州臺歌 陳子昂# 前不見古人 後不見來者# 念天地之悠悠 獨愴然而涕下# &gt;&gt;&gt;print(\"登幽州臺歌\\t陳子昂\\n\")print(\"前不見古人\\t後不見來者\")print(\"念天地之悠悠\\t獨愴然而涕下\") 登幽州臺歌 陳子昂 前不見古人 後不見來者 念天地之悠悠 獨愴然而涕下 12345678910111213141516171819# 習題2# 請撰寫一程式，讓使用者可以分別輸入2位同學的名稱及分數，輸出結果並如下排列： (斜體部分為執行程式時輸入)# &gt;&gt;&gt;# 請輸入A同學姓名:Name_A# 請輸入A同學分數:90# 請輸入B同學姓名:Name_B# 請輸入B同學分數:80# 姓名 分數# Name_A 90# Name_B 80# &gt;&gt;&gt;a1 = input(\"请输入A同学的名字：\")a2 = int(input(\"请输入A同学分数：\"))b1 = input(\"请输入B同学的名字：\")b2 = int(input(\"请输入B同学分数：\"))print(\"姓名\\t分数\")print(\"&#123;&#125;\\t&#123;&#125;\".format(a1,a2))print(\"&#123;&#125;\\t&#123;&#125;\".format(b1,b2)) 请输入A同学的名字：Name_A 请输入A同学分数：90 请输入B同学的名字：Name_B 请输入B同学分数：80 姓名 分数 Name_A 90 Name_B 80","categories":[],"tags":[]},{"title":"Linux常用命令","slug":"2018-05-31_linux_command","date":"2018-05-31T15:39:17.754Z","updated":"2018-10-13T05:54:38.792Z","comments":true,"path":"2018/05/31/2018-05-31_linux_command/","link":"","permalink":"http://yoursite.com/2018/05/31/2018-05-31_linux_command/","excerpt":"","text":"标签（空格分隔）： linux 近段时间开始接触linux，在此记录一些常用的linux命令。 cp 用于复制文件和目录语法： cp [options] sourcedir destdir参数说明：–a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。–d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。-f：覆盖已经存在的目标文件而不给出提示。-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。-l：不复制文件，只是生成链接文件。","categories":[],"tags":[]},{"title":"Vim使用","slug":"2018-05-29_vim","date":"2018-05-28T16:06:12.327Z","updated":"2018-10-13T05:54:59.432Z","comments":true,"path":"2018/05/29/2018-05-29_vim/","link":"","permalink":"http://yoursite.com/2018/05/29/2018-05-29_vim/","excerpt":"","text":"标签（空格分隔）： linux VIM是Linux下面自带的文本编辑器，用处广泛，但是比较难学。本文记录使用vim过程常用的命令，遇到的问题和使用心得。 Ubuntu上的vim ubuntu上,缺省安装的是不完全的vim，在输入模式（Insert mode）使用方向键会出现A,B,C,D。 解决方法：安装完全的vim,命令：1.sudo apt-get update 2.sudo apt-get install vim vim介绍基本上 vi 共分为三种模式，分别是『一般模式』、『编辑模式』与『指令列命令模式』。 这三种模式的作用分别是： 一般模式：以 vi 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、贴上』来处理你的文件数据。 编辑模式：在一般模式中可以进行删除、复制、贴上等等的动作，但是却无法编辑文件内容的！ 要等到你按下『i, I, o, O, a, A, r, R』等任何一个字母之后才会进入编辑模式。注意了！通常在 Linux 中，按下这些按键时，在画面的左下方会出现『 INSERT 或 REPLACE 』的字样，此时才可以进行编辑。而如果要回到一般模式时， 则必须要按下『Esc』这个按键即可退出编辑模式。 指令列命令模式：在一般模式当中，输入『 : / ? 』三个中的任何一个按钮，就可以将光标移动到最底下那一行。在这个模式当中， 可以提供你『搜寻资料』的动作，而读取、存盘、大量取代字符、离开 vi 、显示行号等等的动作则是在此模式中达成的！ 简单的说，我们可以将这三个模式想成底下的图标来表示：一般模式可与编辑模式及指令列模式切换， 但编辑模式与指令列模式之间不可互相切换(此段出处http://cn.linux.vbird.org/linux_basic/0310vi.php) Vim常用命令移动光标的方法 [Ctrl] + [f]：屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b]：屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) 0 或功能键[Home]：这是数字『 0 』：移动到这一行的最前面字符处 (常用) $ 或功能键[End]：移动到这一行的最后面字符处(常用) G： 移动到这个档案的最后一行(常用) gg： 移动到这个档案的第一行，相当于 1G 啊！ (常用) n：n 为数字。光标向下移动 n 行(常用)搜寻与取代 /word：向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) :n1,n2s/word1/word2/g：n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：『:100,200s/vbird/VBIRD/g』。(常用) :1,$s/word1/word2/g：从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) :1,$s/word1/word2/gc：从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)删除、复制与贴上 x, X：在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) dd：删除游标所在的那一整列(常用) ndd：n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列 (常用) yy：复制游标所在的那一行(常用) nyy：n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列(常用) p, P：p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) u：复原前一个动作。(常用) [Ctrl]+r：重做上一个动作。(常用) . :不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)","categories":[],"tags":[]},{"title":"MTF测试图卡规格","slug":"2018-05-28_MTF_Chart_Size","date":"2018-05-28T12:14:35.310Z","updated":"2018-10-13T05:55:19.050Z","comments":true,"path":"2018/05/28/2018-05-28_MTF_Chart_Size/","link":"","permalink":"http://yoursite.com/2018/05/28/2018-05-28_MTF_Chart_Size/","excerpt":"","text":"标签（空格分隔）： 原创 工作总结 camera 1.Imatest Chart Finder计算图卡大小测试camera MTF时，需要知道所需要的图卡的大小，Imatest提供了一个网页，只要输入sensor的像素，镜头的视场角，还有镜头到图卡的距离就可以得出图卡的大小。网页链接Imatest Chart Finder。下图为两百万像素sensor，和视场角为74.5度的镜头，最小物距为0.5m的摄像头模组所需的图卡大小为66.28cm*37.28cm 2.通过像素尺寸（Pixel size），对焦距离，焦距（EFL）计算图卡尺寸根据成像原理可得下图，上面的焦点与被摄物体形成的三角形，下面是焦点与图像传感器形成的三角形，两个三角形相似。这样就可以求出Y值。则图卡的宽度就等于sensor宽度像素点数目乘上Y值，图卡的宽度就等于sensor的长度像素点乘上Y值。 5/29/2018 11:36:25 PM 写的有点乱~","categories":[],"tags":[]},{"title":"研究Camera需要学习的知识","slug":"2018-05-26_camera_base_knowledge","date":"2018-05-26T07:51:50.024Z","updated":"2018-10-13T05:56:00.576Z","comments":true,"path":"2018/05/26/2018-05-26_camera_base_knowledge/","link":"","permalink":"http://yoursite.com/2018/05/26/2018-05-26_camera_base_knowledge/","excerpt":"","text":"标签（空格分隔）： 原创 camera 数字成像系统 人眼是性能优良的成像系统，数字成像系统就是模仿人眼，将自然界的中光信号转换成电信号，然后将模拟电信号转换成数字信号的过程。camera就是典型数字成像系统，典型的成像系统如下图：camera是典型数字成像系统，要对camera有深入的了解，大概需要掌握以下几方面的知识： 光学 颜色科学 CMOS/CCD image sensor ISP 数字图像处理 当然，camera的光圈和调焦还会涉及机械和电路方面的知识。本博客会根据以上四个方面陆续更新与camera有关的知识。","categories":[],"tags":[]},{"title":"软件测试基本知识","slug":"2018-05-26_Solfware_Test","date":"2018-05-26T00:30:32.422Z","updated":"2018-10-13T05:55:38.776Z","comments":true,"path":"2018/05/26/2018-05-26_Solfware_Test/","link":"","permalink":"http://yoursite.com/2018/05/26/2018-05-26_Solfware_Test/","excerpt":"","text":"标签（空格分隔）： 测试软件测试测试模式 传统的瀑布模型 常用W模型 测试过程 单元测试 -&gt; 集成测试 -&gt; 确认测试 -&gt; 系统测试 -&gt; 验收测试 软件测试方法分为白盒测试和黑盒测试 黑盒测试:软件测试以黑盒测试为主，黑盒测试安装需求进行功能测试，黑盒测试还可以分为功能测试和非功能测试。非功能测试有强度测试，性能测试，安全测试，相容性测试等。功能测试方法有等价类划分法（把无限的范围变为有限的），边界值划分法，错误推测法，因果图法，决策法，场景法。 白盒测试：主要是对软件代码进行测试，通常需要掌握一定的编码知识。常用的方法有程序插椿法，逻辑覆盖法，基本路径测试法等。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-03-24T16:23:19.075Z","updated":"2018-03-24T16:23:19.075Z","comments":true,"path":"2018/03/25/hello-world/","link":"","permalink":"http://yoursite.com/2018/03/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}